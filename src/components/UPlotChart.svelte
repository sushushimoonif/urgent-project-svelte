<script lang="ts">
  import { onMount, onDestroy } from "svelte";

  interface Curve {
    name: string;
  }

  interface Props {
    chartId: number;
    chartName: string;
    curves: Curve[];
    data: number[][];
    xRange?: number[] | null;
  }

  let { chartId, chartName, curves, data, xRange }: Props = $props();

  let chartContainer: HTMLDivElement;
  let fullscreenChartContainer: HTMLDivElement;
  let uplot: any = null;
  let uPlot: any = null;
  let isLoading = $state(true);
  let loadError = $state(false);
  let isFullscreen = $state(false);
  
  // 缩放状态管理
  let originalXRange = $state<[number, number] | null>(null);
  let isZoomed = $state(false);

  // Tooltip状态
  let showTooltip = $state(false);
  let tooltipPosition = $state({ x: 0, y: 0 });
  let tooltipData = $state<{
    time: string;
    values: Array<{ name: string; value: string; color: string }>;
  }>({
    time: "",
    values: [],
  });

  // 颜色配置
  const colors = [
    "#3b82f6", // 蓝色
    "#ef4444", // 红色
    "#10b981", // 绿色
    "#f59e0b", // 黄色
    "#8b5cf6", // 紫色
    "#f97316", // 橙色
  ];

  // 全屏切换函数
  function toggleFullscreen() {
    isFullscreen = !isFullscreen;
    setTimeout(() => {
      initChart();
    }, 300);
  }

  // 动态加载uPlot库
  async function loadUPlot() {
    if (typeof window === "undefined") return;

    try {
      isLoading = true;
      loadError = false;

      if ((window as any).uPlot) {
        uPlot = (window as any).uPlot;
        console.log("uPlot库已存在");
        initChart();
        return;
      }

      const script = document.createElement("script");
      script.src = "/lib/uPlot.iife.js";
      script.onload = () => {
        uPlot = (window as any).uPlot;
        if (uPlot) {
          console.log("uPlot库加载成功");
          initChart();
        } else {
          console.error("uPlot库加载后未找到uPlot对象");
          loadError = true;
        }
        isLoading = false;
      };
      script.onerror = () => {
        console.error("uPlot库加载失败");
        loadError = true;
        isLoading = false;
      };

      const existingScript = document.querySelector('script[src="/lib/uPlot.iife.js"]');
      if (!existingScript) {
        document.head.appendChild(script);
      } else {
        if ((window as any).uPlot) {
          uPlot = (window as any).uPlot;
          initChart();
          isLoading = false;
        } else {
          existingScript.addEventListener("load", () => {
            uPlot = (window as any).uPlot;
            if (uPlot) {
              initChart();
            } else {
              loadError = true;
            }
            isLoading = false;
          });
        }
      }
    } catch (error) {
      console.error("uPlot库加载失败:", error);
      loadError = true;
      isLoading = false;
    }
  }

  // 初始化图表
  function initChart() {
    const currentContainer = isFullscreen ? fullscreenChartContainer : chartContainer;
    
    if (!uPlot || !currentContainer) {
      console.log("uPlot或容器未准备好", { uPlot: !!uPlot, container: !!currentContainer, isFullscreen });
      return;
    }

    // 清理现有图表
    if (uplot) {
      cleanupGraySelectionMask(uplot);
      uplot.destroy();
      uplot = null;
    }

    // 终极灰色遮罩样式应用函数 - 使用最强力的方法
    function applyUltimateGrayMask(element: HTMLElement) {
      if (!element) return;
      
      // 清除所有现有样式和类名
      element.removeAttribute('style');
      element.className = '';
      
      // 使用内联样式 + CSS变量 + 重要性声明的组合
      const ultimateGrayStyle = `
        background: rgba(156, 163, 175, 0.8) !important;
        background-color: rgba(156, 163, 175, 0.8) !important;
        border: 1px solid rgba(156, 163, 175, 0.6) !important;
        z-index: 99999 !important;
        pointer-events: none !important;
        position: absolute !important;
        opacity: 0.8 !important;
      `;
      
      // 多重设置确保样式生效
      element.style.cssText = ultimateGrayStyle;
      element.setAttribute('style', ultimateGrayStyle);
      
      // 设置CSS变量作为备用
      element.style.setProperty('--selection-bg', 'rgba(156, 163, 175, 0.8)', 'important');
      element.style.setProperty('background', 'var(--selection-bg)', 'important');
      
      // 添加自定义类名和数据属性
      element.classList.add('u-select', 'ultimate-gray-mask');
      element.setAttribute('data-gray-mask', 'true');
      
      console.log('🔥 终极灰色遮罩样式已应用');
    }

    // 超级监控系统 - 多重保险机制
    function setupSuperGrayMaskSystem(u: any) {
      console.log(`🚀 启动超级灰色遮罩监控系统: ${chartName}`);
      
      // 清理之前的监听器
      cleanupGraySelectionMask(u);
      
      // 1. 高频MutationObserver - 监听所有DOM变化
      u.grayMaskObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          // 监听子节点变化
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node as HTMLElement;
                if (element.classList.contains('u-select') || element.className.includes('u-select')) {
                  applyUltimateGrayMask(element);
                  console.log('🔍 Observer: 新增选择框，应用灰色');
                }
                // 检查所有子元素
                const selectElements = element.querySelectorAll('.u-select');
                selectElements.forEach(sel => applyUltimateGrayMask(sel as HTMLElement));
              }
            });
          }
          
          // 监听属性变化
          if (mutation.type === 'attributes') {
            const element = mutation.target as HTMLElement;
            if (element.classList.contains('u-select') || element.className.includes('u-select')) {
              // 延迟应用，确保uPlot的样式设置完成后再覆盖
              setTimeout(() => {
                applyUltimateGrayMask(element);
                console.log('🔍 Observer: 属性变化，重新应用灰色');
              }, 1);
            }
          }
        });
      });
      
      // 监听所有可能的变化
      u.grayMaskObserver.observe(u.root, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style', 'class', 'data-*'],
        characterData: false
      });
      
      // 2. 超高频定时器 - 每5ms检查一次
      u.grayMaskInterval = setInterval(() => {
        const selectElements = u.root.querySelectorAll('.u-select');
        selectElements.forEach((element: HTMLElement) => {
          const currentBg = getComputedStyle(element).backgroundColor;
          const hasGrayMask = element.getAttribute('data-gray-mask') === 'true';
          
          // 如果背景不是灰色或者没有标记，重新应用
          if (!currentBg.includes('156, 163, 175') || !hasGrayMask) {
            applyUltimateGrayMask(element);
            console.log('⏰ 定时器: 重新应用灰色遮罩');
          }
        });
      }, 5); // 5ms超高频检查
      
      // 3. 事件监听器 - 监听所有鼠标事件
      const eventHandlers = {
        mousedown: (e: MouseEvent) => {
          console.log('🖱️ 鼠标按下事件');
          // 立即和延迟检查
          [0, 1, 5, 10, 20].forEach(delay => {
            setTimeout(() => {
              const selectElements = u.root.querySelectorAll('.u-select');
              selectElements.forEach((element: HTMLElement) => {
                applyUltimateGrayMask(element);
              });
            }, delay);
          });
        },
        
        mousemove: (e: MouseEvent) => {
          const selectElements = u.root.querySelectorAll('.u-select');
          if (selectElements.length > 0) {
            selectElements.forEach((element: HTMLElement) => {
              applyUltimateGrayMask(element);
            });
          }
        },
        
        mouseup: (e: MouseEvent) => {
          console.log('🖱️ 鼠标释放事件');
          setTimeout(() => {
            const selectElements = u.root.querySelectorAll('.u-select');
            selectElements.forEach((element: HTMLElement) => {
              applyUltimateGrayMask(element);
            });
          }, 1);
        }
      };
      
      // 添加事件监听器
      Object.entries(eventHandlers).forEach(([event, handler]) => {
        u.root.addEventListener(event, handler, { passive: true });
      });
      
      // 保存引用以便清理
      u.grayMaskEventHandlers = eventHandlers;
      
      // 4. 立即处理现有元素
      const existingSelects = u.root.querySelectorAll('.u-select');
      existingSelects.forEach((element: HTMLElement) => {
        applyUltimateGrayMask(element);
        console.log('🎯 立即处理现有选择框');
      });
      
      console.log(`✅ 超级灰色遮罩监控系统已启动: ${chartName}`);
    }

    // 清理函数
    function cleanupGraySelectionMask(u: any) {
      if (u.grayMaskObserver) {
        u.grayMaskObserver.disconnect();
        u.grayMaskObserver = null;
        console.log('🧹 清理 MutationObserver');
      }
      if (u.grayMaskInterval) {
        clearInterval(u.grayMaskInterval);
        u.grayMaskInterval = null;
        console.log('🧹 清理定时器');
      }
      if (u.grayMaskEventHandlers) {
        Object.entries(u.grayMaskEventHandlers).forEach(([event, handler]) => {
          u.root.removeEventListener(event, handler as EventListener);
        });
        u.grayMaskEventHandlers = null;
        console.log('🧹 清理事件监听器');
      }
    }

    // 构建series配置
    const series = [
      {
        label: "时间",
        stroke: "transparent",
        fill: "transparent",
      },
      ...curves.map((curve, index) => ({
        label: curve.name,
        stroke: colors[index % colors.length],
        width: 1,
        fill: "transparent",
        points: {
          show: false,
        },
      })),
    ];

    // uPlot配置
    const opts = {
      width: isFullscreen ? window.innerWidth - 100 : (currentContainer.clientWidth || 800),
      height: isFullscreen ? window.innerHeight - 200 : 300,
      series: series,
      axes: [
        {
          label: "时间 (秒)",
          labelSize: 12,
          labelFont: "12px monospace",
          stroke: "#e5e7eb",
          grid: {
            show: true,
            stroke: "#4b5563",
            width: 1,
          },
          ticks: {
            show: true,
            stroke: "#d1d5db",
            width: 1,
            size: 8,
          },
          splits: (
            u: any,
            axisIdx: number,
            scaleMin: number,
            scaleMax: number,
            foundIncr: number,
            foundSpace: number,
          ) => {
            const customIncr = foundIncr * 2;
            const splits = [];
            let val = Math.ceil(scaleMin / customIncr) * customIncr;
            while (val <= scaleMax) {
              splits.push(val);
              val += customIncr;
            }
            return splits;
          },
        },
        {
          label: "数值",
          labelSize: 12,
          labelFont: "12px monospace",
          stroke: "#9ca3af",
          grid: {
            show: true,
            stroke: "#374151",
            width: 1,
          },
          ticks: {
            show: true,
            stroke: "#6b7280",
            width: 1,
          },
        },
      ],
      legend: {
        show: false,
      },
      cursor: {
        show: true,
        sync: {
          key: `chart-${chartId}`,
        },
        drag: {
          setScale: false,
          x: true,
          y: false,
        },
        points: {
          show: true,
          size: 6,
          width: 1,
          stroke: (u: any, seriesIdx: number) => {
            return series[seriesIdx]?.stroke || "#666";
          },
          fill: "#1f2937",
        },
      },
      scales: {
        x: {
          time: false,
          auto: !xRange || xRange.length !== 2,
          ...(xRange && xRange.length === 2
            ? {
                range: () => xRange,
              }
            : {}),
        },
        y: {
          auto: true,
          range: (u: any, dataMin: number, dataMax: number) => {
            const range = dataMax - dataMin;
            const margin = range * 0.1;
            return [dataMin - margin, dataMax + margin];
          },
        },
      },
      hooks: {
        init: [
          (u: any) => {
            console.log(`🎬 init hook: 图表 ${chartName} 初始化`);
            setTimeout(() => {
              setupSuperGrayMaskSystem(u);
            }, 10);
          }
        ],
        ready: [
          (u: any) => {
            console.log(`✅ ready hook: 图表 ${chartName} 准备就绪`);
            setTimeout(() => {
              setupSuperGrayMaskSystem(u);
            }, 50);
          }
        ],
        setData: [
          (u: any) => {
            console.log(`📊 setData hook: 图表 ${chartName} 数据更新`);
            setTimeout(() => {
              setupSuperGrayMaskSystem(u);
            }, 20);
          }
        ],
        setScale: [
          (u: any) => {
            console.log(`🔍 setScale hook: 图表 ${chartName} 缩放更新`);
            setTimeout(() => {
              setupSuperGrayMaskSystem(u);
            }, 50);
          }
        ],
        setSelect: [
          (u: any) => {
            const select = u.select;
            const { left, top, width, height } = select;
            
            console.log(`📦 setSelect hook: 图表 ${chartName} 选择操作`, { width, height });
            
            // 立即强制应用灰色样式 - 多重时间点确保
            const forceGrayNow = () => {
              const selectElements = u.root.querySelectorAll('.u-select');
              selectElements.forEach((element: HTMLElement) => {
                applyUltimateGrayMask(element);
                console.log('📦 setSelect: 强制应用灰色遮罩');
              });
            };
            
            // 立即执行 + 多重延迟确保
            forceGrayNow();
            [1, 2, 5, 10, 15, 20, 30, 50, 100, 200].forEach(delay => {
              setTimeout(forceGrayNow, delay);
            });
            
            if (width > 10) {
              // 隐藏选择遮罩
              const selectDiv = u.root.querySelector('.u-select');
              if (selectDiv) {
                selectDiv.style.display = 'none';
              }
              
              // 保存原始范围
              if (!isZoomed) {
                const xScale = u.scales.x;
                originalXRange = [xScale.min, xScale.max];
                isZoomed = true;
              }
              
              // 计算选择区域对应的数据范围
              const xMin = u.posToVal(left, 'x');
              const xMax = u.posToVal(left + width, 'x');
              
              // 缩放
              u.setScale('x', { min: xMin, max: xMax });
              u.setSelect({ left: 0, top: 0, width: 0, height: 0 }, false);
              
              console.log(`图表 ${chartName} 缩放到X轴范围: [${xMin.toFixed(2)}, ${xMax.toFixed(2)}]`);
              
              // 缩放完成后重新启动监控系统
              setTimeout(() => {
                setupSuperGrayMaskSystem(u);
                console.log(`🔄 缩放完成后重新启动监控系统: ${chartName}`);
              }, 100);
            }
          }
        ],
        setCursor: [
          (u: any) => {
            const { left, top, idx } = u.cursor;

            if (idx !== null && idx !== undefined && data[idx]) {
              showTooltip = true;

              const rect = u.root.getBoundingClientRect();
              tooltipPosition = {
                x: left + rect.left,
                y: top + rect.top,
              };

              const timeValue = data[idx][0];
              const values = curves.map((curve, index) => ({
                name: curve.name,
                value: data[idx][index + 1]?.toFixed(3) || "0.000",
                color: colors[index % colors.length],
              }));

              tooltipData = {
                time: `时间: ${timeValue.toFixed(3)}s`,
                values: values,
              };
            } else {
              showTooltip = false;
            }
          },
        ],
      },
    };

    try {
      const transformedData = transformDataForUPlot(data);
      uplot = new uPlot(opts, transformedData, currentContainer);
      
      currentContainer.addEventListener('dblclick', handleDoubleClick);
      
      console.log(`图表 ${chartName} 初始化成功，数据点数: ${data.length}, 全屏模式: ${isFullscreen}`);
      isLoading = false;
      
      // 初始化完成后启动监控系统
      setTimeout(() => {
        setupSuperGrayMaskSystem(uplot);
        console.log(`图表 ${chartName} 初始化完成，启动监控系统`);
      }, 100);
    } catch (error) {
      console.error(`图表 ${chartName} 初始化失败:`, error);
      loadError = true;
      isLoading = false;
    }
  }

  // 双击重置缩放
  function handleDoubleClick(event: MouseEvent) {
    if (uplot && isZoomed && originalXRange) {
      uplot.setScale('x', { min: originalXRange[0], max: originalXRange[1] });
      isZoomed = false;
      originalXRange = null;
      console.log(`图表 ${chartName} 缩放已重置`);
      event.preventDefault();
    }
  }

  // 将数据转换为uPlot格式
  function transformDataForUPlot(inputData: number[][]): number[][] {
    if (!inputData || inputData.length === 0) {
      return [[], ...curves.map(() => [])];
    }

    const timeData = inputData.map((row) => row[0] || 0);
    const seriesData = curves.map((_, index) => {
      return inputData.map((row) => row[index + 1] || 0);
    });

    return [timeData, ...seriesData];
  }

  function updateChart() {
    if (!uplot || !data) return;

    try {
      const transformedData = transformDataForUPlot(data);

      setTimeout(() => {
        uplot.setData(transformedData);

        if (data.length > 20) {
          const latestTime = data[data.length - 1][0];
          setTimeout(() => {
            uplot.setScale("x", {
              min: 0,
              max: latestTime,
            });
          }, 150);
        }
      }, 100);

      console.log(`图表 ${chartName} 数据更新成功，当前数据点: ${data.length}`);
    } catch (error) {
      console.error(`图表 ${chartName} 数据更新失败:`, error);
    }
  }

  // 响应式更新数据
  $effect(() => {
    if (data && uplot) {
      updateChart();
    }
  });

  // 响应式更新曲线配置
  $effect(() => {
    if (curves && uplot) {
      initChart();
    }
  });

  function handleResize() {
    if (uplot) {
      const currentContainer = isFullscreen ? fullscreenChartContainer : chartContainer;
      if (!currentContainer) return;
      
      const newWidth = isFullscreen ? window.innerWidth - 100 : currentContainer.clientWidth;
      const newHeight = isFullscreen ? window.innerHeight - 200 : 300;
      
      uplot.setSize({
        width: newWidth,
        height: newHeight
      });
    }
  }

  onMount(() => {
    console.log(`开始加载图表 ${chartName}`);
    loadUPlot();
    window.addEventListener("resize", handleResize);
  });

  onDestroy(() => {
    if (uplot) {
      cleanupGraySelectionMask(uplot);
      
      const currentContainer = isFullscreen ? fullscreenChartContainer : chartContainer;
      if (currentContainer) {
        currentContainer.removeEventListener('dblclick', handleDoubleClick);
      }
      
      uplot.destroy();
      uplot = null;
    }

    window.removeEventListener("resize", handleResize);
  });
</script>

<!-- uPlot CSS样式 -->
<svelte:head>
  <link rel="stylesheet" href="/lib/uPlot.min.css" />
  <style>
    /* 终极灰色遮罩样式 - 使用最高优先级 */
    .u-select,
    .ultimate-gray-mask,
    [data-gray-mask="true"] {
      background: rgba(156, 163, 175, 0.8) !important;
      background-color: rgba(156, 163, 175, 0.8) !important;
      border: 1px solid rgba(156, 163, 175, 0.6) !important;
      z-index: 99999 !important;
      pointer-events: none !important;
      opacity: 0.8 !important;
    }
    
    /* 确保在所有状态下都应用灰色样式 */
    .uplot .u-select {
      background: rgba(156, 163, 175, 0.8) !important;
      background-color: rgba(156, 163, 175, 0.8) !important;
      border: 1px solid rgba(156, 163, 175, 0.6) !important;
    }
    
    /* 使用CSS变量作为备用 */
    .u-select {
      background: var(--selection-bg, rgba(156, 163, 175, 0.8)) !important;
    }
  </style>
</svelte:head>

<!-- 全屏模态框 -->
{#if isFullscreen}
  <div class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-8">
    <div class="w-full h-full bg-gray-900 rounded-lg border border-gray-600 relative">
      <!-- 全屏模式下的标题栏 -->
      <div class="flex justify-between items-center p-4 border-b border-gray-700">
        <h3 class="text-xl font-semibold text-gray-200 flex items-center gap-2">
          <svg class="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
          </svg>
          {chartName} - 全屏查看
        </h3>
        <button 
          class="text-gray-400 hover:text-gray-200 p-2 rounded-lg hover:bg-gray-700 transition-colors"
          onclick={toggleFullscreen}
          title="退出全屏"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      
      <!-- 全屏图表容器 -->
      <div class="p-4" style="height: calc(100% - 80px);">
        <div
          bind:this={fullscreenChartContainer}
          class="w-full bg-gray-900 rounded border border-gray-600 relative"
          style="height: calc(100vh - 200px);"
        >
          {#if isLoading}
            <div class="absolute inset-0 flex items-center justify-center text-gray-400 bg-gray-900 rounded">
              <div class="text-center">
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
                <p class="text-lg">加载图表中...</p>
              </div>
            </div>
          {:else if loadError}
            <div class="absolute inset-0 flex items-center justify-center text-gray-400 bg-gray-900 rounded">
              <div class="text-center">
                <div class="text-red-500 text-4xl mb-4">⚠️</div>
                <p class="text-lg">图表加载失败</p>
                <button 
                  class="mt-4 px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded"
                  onclick={() => loadUPlot()}
                >
                  重试
                </button>
              </div>
            </div>
          {:else if !uplot}
            <div class="absolute inset-0 flex items-center justify-center text-gray-400 bg-gray-900 rounded">
              <div class="text-center">
                <div class="text-gray-500 text-4xl mb-4">📊</div>
                <p class="text-lg">准备图表中...</p>
                <p class="text-sm text-gray-500 mt-2">数据点: {data?.length || 0}</p>
              </div>
            </div>
          {/if}
        </div>
      </div>
    </div>
  </div>
{:else}
  <!-- 正常模式 -->
  <div class="w-full h-full relative">
    <!-- 放大缩小按钮 - 右上角悬浮 -->
    <div class="absolute top-2 right-2 z-10 flex gap-1">
      <button 
        class="w-8 h-8 bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded text-gray-300 hover:text-white transition-colors flex items-center justify-center shadow-lg"
        onclick={toggleFullscreen}
        title="全屏查看"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
        </svg>
      </button>
    </div>

    <!-- 图表容器 -->
    <div
      bind:this={chartContainer}
      class="w-full h-80 bg-gray-900 rounded border border-gray-600 relative"
      style="min-height: 300px;"
    >
      {#if isLoading}
        <!-- 加载状态 -->
        <div class="absolute inset-0 flex items-center justify-center text-gray-400 bg-gray-900 rounded">
          <div class="text-center">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
            <p class="text-sm">加载图表中...</p>
          </div>
        </div>
      {:else if loadError}
        <!-- 错误状态 -->
        <div class="absolute inset-0 flex items-center justify-center text-gray-400 bg-gray-900 rounded">
          <div class="text-center">
            <div class="text-red-500 text-2xl mb-2">⚠️</div>
            <p class="text-sm">图表加载失败</p>
            <button
              class="mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded"
              onclick={() => loadUPlot()}
            >
              重试
            </button>
          </div>
        </div>
      {:else if !uplot}
        <!-- 等待初始化 -->
        <div class="absolute inset-0 flex items-center justify-center text-gray-400 bg-gray-900 rounded">
          <div class="text-center">
            <div class="text-gray-500 text-2xl mb-2">📊</div>
            <p class="text-sm">准备图表中...</p>
          </div>
        </div>
      {/if}
    </div>
    
    <!-- 自定义Tooltip -->
    {#if showTooltip}
      <div
        class="absolute z-50 bg-gray-800 border border-gray-600 rounded-lg p-3 shadow-lg pointer-events-none"
        style="left: {tooltipPosition.x}px; top: {tooltipPosition.y}px; background-color: rgba(31, 41, 55, 0.7); backdrop-filter: blur(4px);"
      >
        <!-- 时间显示 -->
        <div class="text-xs text-gray-300 font-mono mb-2 border-b border-gray-600 pb-1">
          {tooltipData.time}
        </div>

        <!-- 曲线数据 -->
        <div class="space-y-1">
          {#each tooltipData.values as item}
            <div class="flex items-center gap-2 text-xs">
              <!-- 颜色指示器 -->
              <div
                class="w-3 h-0.5 rounded"
                style="background-color: {item.color};"
              ></div>
              <!-- 参数名称 -->
              <span class="text-gray-300 flex-1 truncate" title={item.name}>
                {item.name}
              </span>
              <!-- 数值 -->
              <span class="text-white font-mono">
                {item.value}
              </span>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>
{/if}